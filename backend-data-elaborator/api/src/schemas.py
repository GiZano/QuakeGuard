"""
Pydantic Schemas (Data Transfer Objects)
----------------------------------------
Defines request/response structures for API communication.
Includes validation fields for security signatures and model serialization.
"""

from pydantic import BaseModel, ConfigDict, Field
from typing import Optional, List
from datetime import datetime

# ==========================================
# ZONE SCHEMAS
# ==========================================

class ZoneBase(BaseModel):
    city: str 

class ZoneCreate(ZoneBase):
    pass 

class ZoneUpdate(BaseModel):
    city: Optional[str] = None

class Zone(ZoneBase):
    id: int
    model_config = ConfigDict(from_attributes=True)


# ==========================================
# MISURATOR (SENSOR) SCHEMAS
# ==========================================

class MisuratorBase(BaseModel):
    active: bool 
    zone_id: int

class MisuratorCreate(MisuratorBase):
    """
    Payload for creating a new sensor.
    Includes GPS and Security credentials.
    """
    latitude: float = Field(..., ge=-90, le=90, description="GPS Latitude")
    longitude: float = Field(..., ge=-180, le=180, description="GPS Longitude")
    
    # The Public Key generated by the ESP32 (Hex string)
    public_key_hex: str = Field(..., description="ECDSA Public Key (NIST256p) in Hex format")

class MisuratorUpdate(BaseModel):
    active: Optional[bool] = None
    zone_id: Optional[int] = None
    public_key_hex: Optional[str] = None

class Misurator(MisuratorBase):
    id: int
    latitude: Optional[float] = None
    longitude: Optional[float] = None
    # We do not return the public key by default to keep responses clean, 
    # but it can be added if needed.

    model_config = ConfigDict(from_attributes=True)


# ==========================================
# MISURATION (DATA POINT) SCHEMAS
# ==========================================

class MisurationBase(BaseModel):
    value: int
    misurator_id: int

class MisurationCreate(MisurationBase): 
    """
    Payload for data ingestion.
    MUST include signature and device timestamp for verification.
    """
    # Timestamp generated by the device (Unix epoch float/int) used for replay protection
    device_timestamp: float 
    
    # The digital signature of "value:device_timestamp"
    signature_hex: str

class MisurationUpdate(BaseModel):
    value: Optional[int] = None
    misurator_id: Optional[int] = None

class Misuration(MisurationBase):
    id: int
    created_at: datetime
    model_config = ConfigDict(from_attributes=True)


# ==========================================
# ANALYTICS & ALERTS SCHEMAS
# ==========================================

class ZoneStats(BaseModel):
    """
    DTO for providing statistical aggregated data about a zone.
    """
    zone_id: int
    city: str
    active_misurators: int
    total_misurators: int
    avg_misuration_value: Optional[float] = None
    last_misuration: Optional[datetime] = None


# --- ALERT DEFINITIONS ---

class AlertBase(BaseModel):
    """
    Base properties shared between creation and retrieval of Alerts.
    """
    zone_id: int
    severity: float
    message: Optional[str] = None
    timestamp: datetime

class AlertCreate(AlertBase):
    """
    Schema for internal creation of alerts (used by the Worker).
    """
    pass

class AlertResponse(AlertBase):
    """
    Schema for API responses returning Alert data.
    Includes the database ID.
    """
    id: int
    
    # Config to allow Pydantic to read data from the SQLAlchemy object
    model_config = ConfigDict(from_attributes=True)